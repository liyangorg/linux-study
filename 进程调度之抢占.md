# 进程调度之抢占
## 基础概念
1. 进程调度： 选择执行哪个进程，什么时候执行，执行多久; 
2. 抢占：强制挂起正在执行程序的动作;
3. 上下文切换： 从一个可执行进程切换到另外一个可执行进程；

## 问题
1. 怎么抢占？
  - schedule()调用context_switch()；
    - 什么时候执行schedule()？
      1. 用户程序代码显示调用；
      2. need_resched标志，preempt_count计数器
2. need_resched标志---> 抢占？
  - 内核检测该标志，如果被设置里，那么就执行schedule()切换到一个新的进程
    - 内核在什么时候检测该标志？如果每个时钟都来检测，性能损耗太大了吧！
    - 这个标志在哪里存放？和进程绑定吗？
3. 抢占发生在什么时候？
  - 用户抢占：
    1. 系统调用返回用户空间时；
    2. 中断处理程序返回用户空间时；
  - 内核抢占：
    1. 只要重新调度时安全的，内核可以在任何时间抢占正在执行的任务；
    2. 中断处理程序正在执行，且返回内核空间之前；
    3. 内核中的任务显式调用schedule()；
    4. 内核中的任务阻塞；
  - 可以推断：内核什么时候检测need_resched标志，在具备抢占的时候吗？
  
  
  下载国外服务器的代码过慢，等下载好之后，结合代码分析该流程
  
  ## 目标： 搞清楚抢占的流程！
      
      
